function y = ffGn(N, tdres, Hinput, noiseType, mu, sigma)
% FFGN Fast (exact) fractional Gaussian noise and Brownian motion generator
%	Y = FFGN(N, tdres, Hinput, mu, sigma) returns a vector 
%   containing a sequence of N samples of fractional Gaussian noise or 
%   fractional Brownian motion. The generation process uses an FFT which
%   makes it very fast.  The input arguments are:
%		N:         length of the output sequence.
%       tdres      time resolution (1/sampling rate)
%		H		   "Hurst" index of the resultant noise (0 < H <= 2).  For 
%				   0 < H <= 1, the output will be fractional Gaussian noise 
%				   with Hurst index H.  For 1 < H <= 2, the output will be 
%                  fractional Brownian motion with Hurst index H-1.  Either 
%                  way, the power spectral density of the output will
%				   be nominally proportional to 1/f^(2H-1).
%		mu		   mean of the noise. [default = 0]
%		sigma	   standard deviation of the noise. [default = 1]
%
% 	References: Davies & Harte (1987); Beran (1994); Bardet et al., 2002
%	This method is based on an embedding of the covariance matrix in a 
%   circulant matrix.	
%
%   Copyright 2003-2005 by B. Scott Jackson
%
%   Changelog:
%   1.5 - 07/06/23 - Adjusted behavior of noiseType flag. Now, if noiseType
%     is 0, we use an RNG stream throughout this function that has a fixed
%     hand-selected seed to provide representative "frozen" noise matched 
%     to the frozen noise generated by the old ffGn.m code. If noiseType is 
%     1, we use the current global RNG to generate fresh noise.
%   1.4 - 11/27/12 - noiseType flag has been added
%   1.3 - 8/28/08 - Sigma is deifined for diff. sponts (mu) and Resampling has been introduced to be compatible with the AN model 
%   1.2 - 3/14/05 - Added some additional documentation and input argument checking.
%   1.1 - 9/15/04 - Added the persistent variables and associated "if"-statement.
%   1.0 - 2/11/03 - Original version.

% Check to see if running under Matlab or Octave
if exist ('OCTAVE_VERSION', 'builtin') ~= 0
    pkg load signal;
end

%---- Check input arguments ---------- %

if ( (nargin < 5) || (nargin > 6) )
	error('Requires Five to Six input arguments.')
end

if (prod(size(N)) ~= 1) || (prod(size(Hinput)) ~= 1) || ~isnumeric(N) || ~isnumeric(Hinput) ...
        || ~isreal(N) || ~isreal(Hinput) || ~isfinite(N) || ~isfinite(Hinput)
	error('All input arguments must be finite real scalars.')
end

if (N <= 0)
	error('Length of the return vector must be positive.')
end

if (tdres > 1)
	error('Original sampling rate should be checked.')
end 

if (Hinput < 0) || (Hinput > 2)
	error('The Hurst parameter must be in the interval (0,2].')
end

if (nargin > 4)
	if (prod(size(mu)) ~= 1) || ~isnumeric(mu) || ~isreal(mu) || ~isfinite(mu)
		error('All input arguments must be finite real scalars.')
	end
end
	
if (nargin > 5)
	if (prod(size(sigma)) ~= 1) || ~isnumeric(sigma) || ~isreal(sigma) || ~isfinite(sigma)
		error('All input arguments must be finite real scalars.')
	end
	if (sigma <= 0)
		error('Standard deviation must be greater than zero.')
	end
end

% Based on noiseType switch, we will set `stream` to be equal either to 
% a random number stream with a fixed seed or the random number stream of
% the global RNG. This `stream` object can be used with `randn` below as:
%     randn(stream, n1, n2, ...)
% to the generation of numbers by `randn` to suit our needs.
if noiseType == 0
	% If noiseType == 0, we select RNG stream to be based on a fixed seed.
	% This produces noise that is "frozen" across repeated calls to this
	% function. The seed of 37 and the v4 algorithm are selected to match 
	% the noise generated by the call `randn('seed', 37); randn(1, n)` used
	% in previous versions of the code to generate "frozen" noise.
	stream = RandStream('v4', 'Seed', 37);
elseif noiseType == 1
	% if noiseType == 1, we select RNG stream to be current global RNG.
	% This produces noise that is "fresh" across repeated calls to this
	% function (i.e., different each time).
	stream = RandStream.getGlobalStream();
else
	error('noiseType must be 0 (fixed) or 1 (fresh)');
end

% Downsampling No. of points to match with those of Scott jackson (tau 1e-1)
resamp = ceil(1e-1/tdres);
nop = N; N = ceil(N/resamp)+1; 
if (N<10)
    N = 10;
end

% Determine whether fGn or fBn should be produced.
if ( Hinput <= 1 )
	H = Hinput;
	fBn = 0;
else
	H = Hinput - 1;
	fBn = 1;
end

% Calculate the fGn.
if (H == 0.5)
	y = randn(stream, 1, N);  % If H=0.5, then fGn is equivalent to white Gaussian noise.
else
    % If this function was already in memory before being called this time,
    % AND the values for N and H are the same as the last time it was
    % called, then the following (persistent) variables do not need to be
    % recalculated.  This was done to improve the speed of this function,
    % especially when many samples of a single fGn (or fBn) process are
    % needed by the calling function.
    persistent Zmag Nfft Nlast Hlast
    if isempty(Zmag) || isempty(Nfft) || isempty(Nlast) ||isempty(Hlast) || N ~= Nlast || H ~= Hlast
		% The persistent variables must be (re-)calculated.
        Nfft = 2^ceil(log2(2*(N-1)));
		NfftHalf = round(Nfft/2);
		
		k = [0:NfftHalf, (NfftHalf-1):-1:1];
		Zmag = 0.5 .* ( (k+1).^(2.*H) - 2.*k.^(2.*H) + (abs(k-1)).^(2.*H) );
		clear k
		
		Zmag = real(fft(Zmag));
		if ( any(Zmag < 0) )
			error('The fast Fourier transform of the circulant covariance had negative values.');
		end
        Zmag = sqrt(Zmag);
        
        % Store N and H values in persistent variables for use during subsequent calls to this function.
        Nlast = N;
        Hlast = H;
	end
    
	% Note that we use `randn(stream, n1, n2)` here instead of simply `randn(n1, n2)` to 
	% control whether the noise is "frozen" or "fresh" based on how `stream` was set above
	Z = Zmag.*(randn(stream, 1, Nfft) + i.*randn(stream, 1, Nfft));
	
	y = real(ifft(Z)) .* sqrt(Nfft);
	clear Z
	
	y((N+1):end) = [];
end

% Convert the fGn to fBn, if necessary.
if (fBn)
	y = cumsum(y);
end

% Resampling back to original (1/tdres): match with the AN model
y = resample(y,resamp,1);  % Resampling to match with the AN model

% define standard deviation
if (nargin < 6)
    if mu<0.5
        sigma = 1;%5  
    else
        if mu<18
            sigma = 30;%50   % 7 when added after powerlaw
        else
            sigma = mu/2;%200;  % 40 when added after powerlaw        
        end
    end
end
y = y*sigma;

y = y(1:nop);









